name: OpenAPI
on:
  push:
    branches:
      - master
    tags:
      - 'v*'
  pull_request_target:

permissions: {}

jobs:
  openapi-head:
    name: OpenAPI - HEAD
    runs-on: ubuntu-latest
    permissions: read-all
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}

      - name: Setup .NET
        uses: actions/setup-dotnet@2016bd2012dba4e32de620c46fe006a3ac9f0602 # v5.0.1
        with:
          dotnet-version: '9.0.x'

      - name: Generate openapi.json
        run: dotnet test tests/Jellyfin.Server.Integration.Tests/Jellyfin.Server.Integration.Tests.csproj -c Release --filter "Jellyfin.Server.Integration.Tests.OpenApiSpecTests"

      - name: Upload openapi.json
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: openapi-head
          retention-days: 14
          if-no-files-found: error
          path: tests/Jellyfin.Server.Integration.Tests/bin/Release/net9.0/openapi.json

  openapi-base:
    name: OpenAPI - BASE
    if: ${{ github.base_ref != '' }}
    runs-on: ubuntu-latest
    permissions: read-all
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          fetch-depth: 0

      - name: Checkout common ancestor
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: |
          git remote add upstream https://github.com/${{ github.event.pull_request.base.repo.full_name }}
          git -c protocol.version=2 fetch --prune --progress --no-recurse-submodules upstream +refs/heads/*:refs/remotes/upstream/* +refs/tags/*:refs/tags/*
          ANCESTOR_REF=$(git merge-base upstream/${{ github.base_ref }} origin/$HEAD_REF)
          git checkout --progress --force $ANCESTOR_REF

      - name: Setup .NET
        uses: actions/setup-dotnet@2016bd2012dba4e32de620c46fe006a3ac9f0602 # v5.0.1
        with:
          dotnet-version: '9.0.x'

      - name: Generate openapi.json
        run: dotnet test tests/Jellyfin.Server.Integration.Tests/Jellyfin.Server.Integration.Tests.csproj -c Release --filter "Jellyfin.Server.Integration.Tests.OpenApiSpecTests"

      - name: Upload openapi.json
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: openapi-base
          retention-days: 14
          if-no-files-found: error
          path: tests/Jellyfin.Server.Integration.Tests/bin/Release/net9.0/openapi.json

  openapi-diff:
    permissions:
      pull-requests: write  #  to create or update comment (peter-evans/create-or-update-comment)

    name: OpenAPI - Difference
    if: ${{ github.event_name == 'pull_request_target' }}
    runs-on: ubuntu-latest
    needs:
      - openapi-head
      - openapi-base
    steps:
      - name: Download openapi-head
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: openapi-head
          path: openapi-head

      - name: Download openapi-base
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: openapi-base
          path: openapi-base

      - name: Detect OpenAPI changes
        id: openapi-diff
        continue-on-error: true
        uses: Shadowghost/oasdiff-action/diff@flatten
        with:
          base: openapi-base/openapi.json
          revision: openapi-head/openapi.json
          flatten-allof: true
          output-to-file: openapi-diff.yaml

      - name: Check for changes
        id: check-diff
        run: |
          if [ -f openapi-diff.yaml ] && [ -s openapi-diff.yaml ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Format changelog
        if: ${{ steps.check-diff.outputs.has_changes == 'true' }}
        run: |
          python3 << 'EOF'
          import yaml
          import re
          from collections import defaultdict

          # Read file and extract just the paths section (before endpoints: which has complex keys)
          with open('openapi-diff.yaml', 'r') as f:
              content = f.read()

          paths_yaml = content.split('\nendpoints:', 1)[0]
          diff = yaml.safe_load(paths_yaml)

          if not diff:
              exit(0)

          # Track DTO changes: dto_type -> {change_desc -> set of endpoints}
          dto_changes = defaultdict(lambda: defaultdict(set))
          endpoint_unique_changes = defaultdict(list)
          current_endpoint = None

          # Structural keywords that are NOT DTO type names
          STRUCTURAL = {'modified', 'added', 'deleted', 'properties', 'schema', 'content',
                        'items', 'allOf', 'anyOf', 'oneOf', 'responses', 'operations',
                        'requestBody', 'parameters', 'additionalProperties', 'nullable',
                        'description', 'from', 'to', 'base', 'revision', 'diff', 'index', 'component'}

          def is_potential_dto(name):
              """Check if a name looks like a DTO type (PascalCase, not a structural keyword)."""
              if not isinstance(name, str):
                  return False
              if name.lower() in {s.lower() for s in STRUCTURAL}:
                  return False
              if name.startswith('application/'):
                  return False
              if name.isdigit():
                  return False
              if name and name[0].isupper():
                  return True
              return False

          def find_dto_and_property(path_parts):
              """Find the DTO type (parent with properties) and the property being changed."""
              parts_list = list(path_parts)
              dto_type = None
              prop_name = None

              for i, part in enumerate(parts_list):
                  if i + 1 < len(parts_list) and parts_list[i + 1] == 'properties':
                      if is_potential_dto(part):
                          dto_type = part
                          if i + 3 < len(parts_list) and parts_list[i + 2] == 'modified':
                              candidate = parts_list[i + 3]
                              if is_potential_dto(candidate):
                                  prop_name = candidate
                          break
                  elif i + 1 < len(parts_list) and parts_list[i + 1] == 'additionalProperties':
                      if is_potential_dto(part):
                          dto_type = part
                          break

              if not dto_type:
                  for part in reversed(parts_list):
                      if is_potential_dto(part):
                          dto_type = part
                          break

              return dto_type, prop_name

          def collect_changes(obj, path_parts):
              """Recursively collect from/to changes."""
              global current_endpoint
              if not isinstance(obj, dict):
                  return

              if 'from' in obj and 'to' in obj:
                  from_val = obj['from']
                  to_val = obj['to']

                  if 'additionalPropertiesAllowed' in path_parts:
                      return

                  dto_type, prop_name = find_dto_and_property(path_parts)
                  change_type = path_parts[-1] if path_parts else 'unknown'

                  if dto_type:
                      if change_type == 'nullable' and prop_name:
                          change_desc = f"`{prop_name}` nullable: `{from_val}` → `{to_val}`"
                      elif change_type == 'nullable':
                          change_desc = f"nullable: `{from_val}` → `{to_val}`"
                      elif change_type == 'description':
                          from_short = str(from_val)[:50] + "..." if len(str(from_val)) > 50 else str(from_val)
                          to_short = str(to_val)[:50] + "..." if len(str(to_val)) > 50 else str(to_val)
                          change_desc = f"description: `{from_short}` → `{to_short}`"
                      else:
                          if prop_name:
                              change_desc = f"`{prop_name}`.`{change_type}`: `{from_val}` → `{to_val}`"
                          else:
                              change_desc = f"`{change_type}`: `{from_val}` → `{to_val}`"
                      dto_changes[dto_type][change_desc].add(current_endpoint)
                  else:
                      prop_path = '/'.join(str(p) for p in path_parts if p not in STRUCTURAL and not str(p).startswith('application/'))
                      if from_val is None:
                          desc = f"`{prop_path}` set to `{to_val}`"
                      elif to_val is None:
                          desc = f"`{prop_path}` removed (was `{from_val}`)"
                      else:
                          desc = f"`{prop_path}`: `{from_val}` → `{to_val}`"
                      endpoint_unique_changes[current_endpoint].append(desc)
                  return

              for key, value in obj.items():
                  if isinstance(value, dict):
                      collect_changes(value, path_parts + [key])
                  elif isinstance(value, list):
                      for i, item in enumerate(value):
                          if isinstance(item, dict):
                              collect_changes(item, path_parts + [key])

          # Process paths
          if 'paths' in diff:
              paths_data = diff['paths']
              for change_type in ['added', 'deleted', 'modified']:
                  if change_type not in paths_data:
                      continue
                  for api_path, path_data in paths_data[change_type].items():
                      if change_type == 'added':
                          endpoint_unique_changes[f"* {api_path}"].append("Endpoint added")
                      elif change_type == 'deleted':
                          endpoint_unique_changes[f"* {api_path}"].append("Endpoint removed")
                      elif 'operations' in path_data:
                          ops = path_data['operations']
                          for op_type in ['added', 'deleted', 'modified']:
                              if op_type not in ops:
                                  continue
                              for method, method_data in ops[op_type].items():
                                  current_endpoint = f"{method.upper()} {api_path}"
                                  if op_type == 'added':
                                      endpoint_unique_changes[current_endpoint].append("Operation added")
                                  elif op_type == 'deleted':
                                      endpoint_unique_changes[current_endpoint].append("Operation removed")
                                  else:
                                      collect_changes(method_data, [])

          # Consolidate similar nullable changes under each DTO
          consolidated_dto_changes = defaultdict(lambda: defaultdict(set))

          for dto_type, changes in dto_changes.items():
              nullable_changes = {}
              other_changes = {}

              for change_desc, endpoints in changes.items():
                  if 'nullable:' in change_desc:
                      match = re.match(r'`(\w+)` nullable: `(\w+)` → `(\w+)`', change_desc)
                      if match:
                          prop, from_v, to_v = match.groups()
                          key = (from_v, to_v)
                          if key not in nullable_changes:
                              nullable_changes[key] = {'props': set(), 'endpoints': set()}
                          nullable_changes[key]['props'].add(prop)
                          nullable_changes[key]['endpoints'].update(endpoints)
                      else:
                          other_changes[change_desc] = endpoints
                  else:
                      other_changes[change_desc] = endpoints

              for (from_v, to_v), data in nullable_changes.items():
                  props = sorted(data['props'])
                  if len(props) > 5:
                      props_str = ', '.join(f'`{p}`' for p in props[:5]) + f" (+{len(props)-5} more)"
                  else:
                      props_str = ', '.join(f'`{p}`' for p in props)
                  change_desc = f"nullable `{from_v}` → `{to_v}` for: {props_str}"
                  consolidated_dto_changes[dto_type][change_desc] = data['endpoints']

              for change_desc, endpoints in other_changes.items():
                  consolidated_dto_changes[dto_type][change_desc] = endpoints

          # Separate DTOs: common (many endpoints) vs endpoint-specific
          THRESHOLD = 5
          common_dtos = {}
          specific_dtos = {}
          for dto_type, changes in consolidated_dto_changes.items():
              total_endpoints = len(set().union(*changes.values()))
              if total_endpoints >= THRESHOLD:
                  common_dtos[dto_type] = changes
              else:
                  specific_dtos[dto_type] = changes

          # Merge specific DTOs into endpoint changes
          for dto_type, changes in specific_dtos.items():
              for ep in set().union(*changes.values()):
                  for change_desc in changes.keys():
                      if ep in changes[change_desc]:
                          if ep not in endpoint_unique_changes:
                              endpoint_unique_changes[ep] = []
                          endpoint_unique_changes[ep].append(f"`{dto_type}`: {change_desc}")

          # Generate summary
          total_endpoints = len(set().union(
              *[set().union(*changes.values()) for changes in consolidated_dto_changes.values()],
              set(endpoint_unique_changes.keys())
          ))
          table = ["| Metric | Count |", "|:--|--:|"]
          table.append(f"| Common DTO/Schema types | {len(common_dtos)} |")
          table.append(f"| Endpoint-specific changes | {len(endpoint_unique_changes)} |")
          table.append(f"| **Total endpoints affected** | **{total_endpoints}** |")
          summary = "\n".join(table)

          def generate_output(max_size=None):
              output = [f'<!--openapi-diff-workflow-comment-->\n## OpenAPI Changes\n{summary}\n']

              # Common DTO changes section
              if common_dtos:
                  output.append('### Schema/DTO Changes\n')
                  output.append('These changes affect multiple endpoints:\n')
                  for dto_type in sorted(common_dtos.keys()):
                      changes = common_dtos[dto_type]
                      total = len(set().union(*changes.values()))
                      output.append(f'<details>\n<summary><code>{dto_type}</code> ({total} endpoints)</summary>\n')
                      for change_desc, endpoints in sorted(changes.items()):
                          output.append(f'- {change_desc}')
                      output.append('\n</details>\n')

              if endpoint_unique_changes:
                  output.append(f'<details>\n<summary>Endpoint-specific changes ({len(endpoint_unique_changes)} endpoints)</summary>\n')
                  endpoints_shown = 0
                  truncated = False
                  for ep in sorted(endpoint_unique_changes.keys()):
                      changes = endpoint_unique_changes[ep]
                      endpoint_block = [f'<details>\n<summary><code>{ep}</code> ({len(changes)} changes)</summary>\n']
                      for change in changes[:20]:
                          endpoint_block.append(f'- {change}')
                      if len(changes) > 20:
                          endpoint_block.append(f'- ... and {len(changes) - 20} more changes')
                      endpoint_block.append('\n</details>\n')

                      if max_size:
                          current_size = len('\n'.join(output))
                          endpoint_size = len('\n'.join(endpoint_block))
                          if current_size + endpoint_size > max_size:
                              truncated = True
                              break

                      output.extend(endpoint_block)
                      endpoints_shown += 1

                  if truncated:
                      remaining = len(endpoint_unique_changes) - endpoints_shown
                      output.append(f'\n*... and {remaining} more endpoints. Download the `openapi-changelog` artifact for the full changelog.*\n')
                  output.append('</details>')

              return '\n'.join(output)

          # Generate full changelog for artifact
          with open('changelog_formatted_full.md', 'w') as f:
              f.write(generate_output())

          # Generate truncated changelog for PR comment (GitHub comments max 65536 chars)
          with open('changelog_formatted.md', 'w') as f:
              f.write(generate_output(max_size=60000))
          EOF

      - name: Upload openapi diff
        if: ${{ always() && steps.check-diff.outputs.has_changes == 'true' }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: openapi-diff
          retention-days: 7
          path: openapi-diff.yaml

      - name: Upload formatted changelog
        if: ${{ always() && steps.check-diff.outputs.has_changes == 'true' }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: openapi-changelog
          retention-days: 7
          path: changelog_formatted_full.md
          if-no-files-found: ignore

      - name: Add changelog to workflow summary
        if: ${{ steps.check-diff.outputs.has_changes == 'true' }}
        run: |
          if [ -f changelog_formatted.md ]; then
            cat changelog_formatted.md >> $GITHUB_STEP_SUMMARY
          fi

      - name: Find difference comment
        uses: peter-evans/find-comment@b30e6a3c0ed37e7c023ccd3f1db5c6c0b0c23aad # v4.0.0
        if: ${{ always() }}
        id: find-comment
        with:
          issue-number: ${{ github.event.pull_request.number }}
          direction: last
          body-includes: openapi-diff-workflow-comment

      - name: Check formatted changelog exists
        id: check-formatted
        if: ${{ always() && steps.check-diff.outputs.has_changes == 'true' }}
        run: |
          if [ -f changelog_formatted.md ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Post or update comment (changes found)
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        if: ${{ always() && steps.check-formatted.outputs.exists == 'true' }}
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-id: ${{ steps.find-comment.outputs.comment-id }}
          edit-mode: replace
          body-path: changelog_formatted.md

      - name: Post raw changelog if formatting failed
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        if: ${{ always() && steps.check-diff.outputs.has_changes == 'true' && steps.check-formatted.outputs.exists == 'false' }}
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-id: ${{ steps.find-comment.outputs.comment-id }}
          edit-mode: replace
          body-path: changelog.md

      - name: Update comment (no changes)
        uses: peter-evans/create-or-update-comment@e8674b075228eee787fea43ef493e45ece1004c9 # v5.0.0
        if: ${{ always() && steps.check-diff.outputs.has_changes == 'false' && steps.find-comment.outputs.comment-id != '' }}
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-id: ${{ steps.find-comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            <!--openapi-diff-workflow-comment-->

            No changes to OpenAPI specification found. See history of this comment for previous changes.

  publish-unstable:
    name: OpenAPI - Publish Unstable Spec
    if: ${{ github.event_name != 'pull_request_target' && !startsWith(github.ref, 'refs/tags/v') && contains(github.repository_owner, 'jellyfin') }}
    runs-on: ubuntu-latest
    needs:
      - openapi-head
    steps:
      - name: Set unstable dated version
        id: version
        run: |-
          echo "JELLYFIN_VERSION=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV
      - name: Download openapi-head
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: openapi-head
          path: openapi-head
      - name: Upload openapi.json (unstable) to repository server
        uses: appleboy/scp-action@ff85246acaad7bdce478db94a363cd2bf7c90345 # v1.0.0
        with:
          host: "${{ secrets.REPO_HOST }}"
          username: "${{ secrets.REPO_USER }}"
          key: "${{ secrets.REPO_KEY }}"
          source: openapi-head/openapi.json
          strip_components: 1
          target: "/srv/incoming/openapi/unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}"
      - name: Move openapi.json (unstable) into place
        uses: appleboy/ssh-action@823bd89e131d8d508129f9443cad5855e9ba96f0 # v1.2.4
        with:
          host: "${{ secrets.REPO_HOST }}"
          username: "${{ secrets.REPO_USER }}"
          key: "${{ secrets.REPO_KEY }}"
          debug: false
          script: |
            if ! test -d /run/workflows; then
                sudo mkdir -p /run/workflows
                sudo chown ${{ secrets.REPO_USER }} /run/workflows
            fi
            (
            flock -x -w 300 200 || exit 1
            TGT_DIR="/srv/repository/main/openapi"
            LAST_SPEC="$( ls -lt ${TGT_DIR}/unstable/ | grep 'jellyfin-openapi' | head -1 | awk '{ print $NF }' )"
            # If new and previous spec don't differ (diff retcode 0), remove incoming and finish
            if diff /srv/incoming/openapi/unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}/openapi.json ${TGT_DIR}/unstable/${LAST_SPEC} &>/dev/null; then
                rm -r /srv/incoming/openapi/unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}
                exit 0
            fi
            # Move new spec into place
            sudo mv /srv/incoming/openapi/unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}/openapi.json ${TGT_DIR}/unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}.json
            # Delete previous jellyfin-openapi-unstable_previous.json
            sudo rm ${TGT_DIR}/jellyfin-openapi-unstable_previous.json
            # Move current jellyfin-openapi-unstable.json symlink to jellyfin-openapi-unstable_previous.json
            sudo mv ${TGT_DIR}/jellyfin-openapi-unstable.json ${TGT_DIR}/jellyfin-openapi-unstable_previous.json
            # Create new jellyfin-openapi-unstable.json symlink
            sudo ln -s unstable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}.json ${TGT_DIR}/jellyfin-openapi-unstable.json
            # Check that the previous openapi unstable spec link is correct
            if [[ "$( readlink ${TGT_DIR}/jellyfin-openapi-unstable_previous.json )" != "unstable/${LAST_SPEC}" ]]; then
                sudo rm ${TGT_DIR}/jellyfin-openapi-unstable_previous.json
                sudo ln -s unstable/${LAST_SPEC} ${TGT_DIR}/jellyfin-openapi-unstable_previous.json
            fi
            ) 200>/run/workflows/openapi-unstable.lock

  publish-stable:
    name: OpenAPI - Publish Stable Spec
    if: ${{ startsWith(github.ref, 'refs/tags/v') && contains(github.repository_owner, 'jellyfin') }}
    runs-on: ubuntu-latest
    needs:
      - openapi-head
    steps:
      - name: Set version number
        id: version
        run: |-
          echo "JELLYFIN_VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV
      - name: Download openapi-head
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: openapi-head
          path: openapi-head
      - name: Upload openapi.json (stable) to repository server
        uses: appleboy/scp-action@ff85246acaad7bdce478db94a363cd2bf7c90345 # v1.0.0
        with:
          host: "${{ secrets.REPO_HOST }}"
          username: "${{ secrets.REPO_USER }}"
          key: "${{ secrets.REPO_KEY }}"
          source: openapi-head/openapi.json
          strip_components: 1
          target: "/srv/incoming/openapi/stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}"
      - name: Move openapi.json (stable) into place
        uses: appleboy/ssh-action@823bd89e131d8d508129f9443cad5855e9ba96f0 # v1.2.4
        with:
          host: "${{ secrets.REPO_HOST }}"
          username: "${{ secrets.REPO_USER }}"
          key: "${{ secrets.REPO_KEY }}"
          debug: false
          script: |
            if ! test -d /run/workflows; then
                sudo mkdir -p /run/workflows
                sudo chown ${{ secrets.REPO_USER }} /run/workflows
            fi
            (
            flock -x -w 300 200 || exit 1
            TGT_DIR="/srv/repository/main/openapi"
            LAST_SPEC="$( ls -lt ${TGT_DIR}/stable/ | grep 'jellyfin-openapi' | head -1 | awk '{ print $NF }' )"
            # If new and previous spec don't differ (diff retcode 0), remove incoming and finish
            if diff /srv/incoming/openapi/stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}/openapi.json ${TGT_DIR}/stable/${LAST_SPEC} &>/dev/null; then
                rm -r /srv/incoming/openapi/stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}
                exit 0
            fi
            # Move new spec into place
            sudo mv /srv/incoming/openapi/stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}/openapi.json ${TGT_DIR}/stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}.json
            # Delete previous jellyfin-openapi-stable_previous.json
            sudo rm ${TGT_DIR}/jellyfin-openapi-stable_previous.json
            # Move current jellyfin-openapi-stable.json symlink to jellyfin-openapi-stable_previous.json
            sudo mv ${TGT_DIR}/jellyfin-openapi-stable.json ${TGT_DIR}/jellyfin-openapi-stable_previous.json
            # Create new jellyfin-openapi-stable.json symlink
            sudo ln -s stable/jellyfin-openapi-${{ env.JELLYFIN_VERSION }}.json ${TGT_DIR}/jellyfin-openapi-stable.json
            # Check that the previous openapi stable spec link is correct
            if [[ "$( readlink ${TGT_DIR}/jellyfin-openapi-stable_previous.json )" != "stable/${LAST_SPEC}" ]]; then
                sudo rm ${TGT_DIR}/jellyfin-openapi-stable_previous.json
                sudo ln -s stable/${LAST_SPEC} ${TGT_DIR}/jellyfin-openapi-stable_previous.json
            fi
            ) 200>/run/workflows/openapi-stable.lock
